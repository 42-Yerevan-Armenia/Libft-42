https://en.wikipedia.org/wiki/C_string_handling

bzero		() ջնջում է str-ի պարունակությունը: Եթե n = 0 է, bzero() ոչինչ չի անում:
malloc		() հատկացնումա հիշողություն size չափով և ցուցիչ/pointer է վերադարձնում հատկացված հիշողությանը:
calloc		() հատկացնումա հիշողության բլոկ, որը հետո այն 0ացնումա (bzero)
isalpha 	('') վերցնումա char ու եթե char-ա վերադարձնումա 1 եթե ոչ 0 (int c - ascii) նույնը մնացածի համար
itoa		() n % 10-ը, օրինակ ուզում ենք վերադարձնի 13 str-ում, 13/10=1 առանց մնացորդի + 3 մնացորդը
			int-ը վերածում է str-ի atoi	() str-ը վերածում է int-ի:
memchr		(void) ինքը նայումա մեր *str-ում առաջին հանդիպած c արժեքը ու իրանից հետո վերադարձնումա իրան n երկարությամբ
memcmp		() համեմատումա str1-ը ու str2-ը, աշխատում է ցանկացած structur-ի հետ: if 1>2 = +, 1<2 = -, 1=2 = 0
strncmp		() համեմատումա str1-ը ու str2-ը, նշելով քանի բայթա համեմատում, աշխատում է միայն char-ով: if 1>2 = + 1<2 = - 1=2 = 0։
memmove		() ի տարբերություն memcpy	()-ի str-ի պարունակությունը copy-ա անում ու պահումա buffer-ի մեջ հետո move-ա անում str-ի մեջ:
			memmove ()-ը ավելի ապահով է, memcpy ()-ը overlaping-ը հաշվի չի առնում, քանի որ համնկնող էլեմենտների դեպքում վարքագիծը անկանխատեսելի է:
			memcpy (dont used buffer) / memmove (use buffer)
memset		() b տողի վրա գրում է c արժեքը len երկարությամբ (վերածվում է unsigned char-ի):
split 		() կարդում է տվյալ str-ը և այն բաժանում այն հատվածից որտեղ առկա է c արժեքով էլեմենտ:
strchr		(char) հայտնաբերում է c-ի առաջին հայտնվելը str-ում և տպում դրանից հետո մնացած պարունակությունը
strrchr 	() նույնը ինչ strchr () սակայն տպումա վերջի հանդիպած c-ից հետո
strdup		() str-ի պարունակությունը copy-ա անում dest-ի մեջ, միաժամանակ տեղ հատկացնելով dest-ին malloc-ում, ու վերադարձնումա malloc(dest)-ի (pointer-ի) պարունակությունը
strjoin		() str1-ին կպցնում է str2-ը: Ի տարբերություն strcat ()-ի ինքը malloc-ով տեղա հատկացնում, դնումա dest-ի մեջ ու վերադարձնումա malloc(dest) պարունակությունը: sizeof(char str) * strlen, +1 -վերջին '0'
strlcpy		() copy-ա անում ու վերադարձնումա պատճենած str-ի size-ը, իսկ strlcat ()-ը` str-ի ու dest-ի size-ը:
strlen		() հաշվարկում է str-ի size-ը:
strmapi		() կիրառում է f ֆունկցիան str-ի յուրաքանչյուր char-ի համար, տեղ հատկացնելով malloc-ում, ու վերադարձնումա փոփոխված str-ը:
striteri 	() նույնը ինչ strmapi ()-ին, սակայն malloc-ը տեղ չի հատկացնում քանի որ void-ա
strnstr		() հայտնաբերում է "needle"-ը "haystack" str-ի len երկարությունում և վերադարձնում այն ու նրանից հետո ինչ կա: Եթե չի բավարարում len-ը՝ NULL, "needle" դատարկ է՝ str:
strtrim		() հեռացնում է str-ի սկզբից և վերջից set-ում առկա էլեմենտները:
substr		() *s-ի մեջ ինչ որ char(substr) index(start)-ից սկցած գրելուա len երկարությամբ, malloc-ով տեղա հատկացնելու մեր str-ին հետո վերադարձնելուա substr-ով փոփոխված str-ը մեզ
fd			() file discript - max 1024 միաժամանակ բացված ֆայլեր, index(0) = standart input, i(1) = s output, i(2) = s error, i(3) = new file, i(-1) = not file if file opend and readed put other i()
toupper		() tolower () տրված char-ը սարքումա մեծատառ կամ փոքրատառ, +-32-ը ascii-իում իրանց միջև հեռավորություննա
libft.h		() որպեսզի չգրենք նույն ֆունկցիաները, մենք ավելացնում ենք իրանց այստեղ որպես linker
makefile	() շատ ֆունկցիաներ կապվում/աշխատացվում/կոմպիլացիա են արվում իրար հետ, :-target որում գրվում են parent-րը, իրանցից ներքև կատարվող command-ներն են:
			ar rcs - ascii, .PHONY - եթե կա target-րի անունով ֆայլ, կատարել make բոլորի համար:
			wildcard-ավելացնել այն .c-րը որոնք գտնվում են Makefile-ի հետ նույն directory-ում:
https://www.learn-c.org/en/Linked_lists
lstnew		() փոփոխական, որը ցույց է տալիս list-ի առաջին կետը: միշտ պետք է ստուգենք՝ malloc-ը վերադարձրել է NULL արժեք, թե ոչ:
				t_list-հանգույց
lstadd_front() ստեղծել նոր lst և հասցեավորել իրեն head-ին
"Create a new item and set its value
Link the new item to point to the head of the list
Set the head of the list to be our new item"
lstadd_back	() ստեղծում ենք current, որը head-ից սկսացծ ցույց է տալիս մեր հաջորդ lst-ն մինչև հասնի վերջինին և նոր ավելացնում new
lstlast		() կատարում է ցիկլային ստուգում մինչև վերջին lst
lstsize		() հաշվում է lst-րի քանակը
lstdellone	() ջնջում է մեր ներկա lst-ի պարունակությունը
lstclear	() մեր ուզածը lst-ն ջնջելու համար պետք է նախ վերահացեավորել նախորդի նախորդին:
"Iterate to the node before the node we wish to delete
Save the node we wish to delete in a temporary pointer
Set the previous node's next pointer to point to the node after the node we wish to delete
Delete the node using the temporary pointer"
lstiter		() կիրառում f ֆունկցիան յուր. lst-ի պարունակության համար
lstmap		() կատարում է lstiter()-ը, հետո ստեղծում lst արդեն փոփոխված f-ով
//split with free for future projects
